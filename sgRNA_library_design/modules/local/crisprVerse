process CRISPRverse {
label "CRISPRverse"

input:
    path(bedfile)
    path(bsgenome)
    path(CFD_files)
    path(bowtie_index)


    output:
    path("${bedfile.getSimpleName()}.txt"), emit : crispr_base
    path("${bedfile.getSimpleName()}_aln.txt"), emit : aln
    path("${bedfile.getSimpleName()}_failed.txt"), emit : failed , optional: true
    path("${bedfile.getSimpleName()}_failed_aln.txt"), emit : failed_aln , optional: true


// publishDir "${params.Auxiliary_files}/Crispr/", pattern: "*_aln.txt", mode: "copy"
        script:


// By default $params.CFD_Threshold and $params.CFD_Count can be null and the transfert to R is more Rocky
def No_CFD = "F"
def CFD_C = 0
def CFD_T = 1
if ("$params.CFD_Threshold" == "" || "$params.CFD_Count" == "") {
    No_CFD = "T"
} else {
    CFD_C = params.CFD_Count
    CFD_T = params.CFD_Threshold
}



    """
    
        #!/usr/bin/env Rscript
        unixtools::set.tempdir("${params.R_temporary_dir}")
        library(crisprDesign)
        library(Rbowtie)
        library(Biostrings)
        library(crisprScore)
        library(dplyr)
        library(tibble)

        install.packages(
        "$bsgenome",
        repos   = NULL,
        type    = "source",
        lib     = "."
        )
        bsgenome_dirs <- list.dirs(path = ".", full.names = TRUE, recursive = FALSE)
        bsgenome_name <- bsgenome_dirs[grepl("BSgenome", bsgenome_dirs)]
        files <- list.files(path = ".", full.names = TRUE, recursive = TRUE)
        print(files)
        print(files[grepl(".1.ebwt", files)])
        print(files[grepl("*ebwt", files)])
        prefix_index <- sub(".1.ebwt", "", files[grepl("ebwt", files)][1])
        print(prefix_index)
        print('::message:: loaded')
        print(bsgenome_name)

        library(basename(bsgenome_name), lib.loc = ".", character.only = TRUE)
        bsgenome <- get(basename(bsgenome_name))
        print(basename(bsgenome_name))
        chunksize  <- ${params.crispr_chunksize}

        process_dna_alignments <- function(seq_df, align_df, 
                                           score_threshold_col = "threshold",
                                           seq_id_col = "protospacer",
                                           align_score_col = "alignment_score",
                                           max_alignments = 10) {
          
          # Step 1: Count alignments exceeding threshold for each sequence
          alignment_counts <- align_df %>%
            # Join with sequence data to get thresholds
            left_join(seq_df %>% select(all_of(c(seq_id_col, score_threshold_col))), 
                      by = seq_id_col) %>%
            # Filter alignments exceeding threshold
            filter(.data[[align_score_col]] > .data[[score_threshold_col]]) %>%
            # Count alignments per sequence
            group_by(.data[[seq_id_col]]) %>%
            summarise(n_alignments_above_threshold = n(), .groups = 'drop')
          
          # Return results
          return(as.data.frame(alignment_counts))
        }


        getExtendedSequences <- function(guideSet,
                                          start,
                                          end
        ){
            gr <- guideSet
            wh_neg <- which(as.character(strand(gr))=="-")
            # The order of resizing IRanges matters
            # to presever the validity of a positive width.
            if (start>0 & end>0){
                end(gr)   <- end(guideSet)+end
                start(gr) <- start(guideSet)+start
                start(gr)[wh_neg] <- start(guideSet)[wh_neg]-end
                end(gr)[wh_neg]   <- end(guideSet)[wh_neg]-start
            } else {
                start(gr) <- start(guideSet)+start
                end(gr)   <- end(guideSet)+end
                end(gr)[wh_neg]   <- end(guideSet)[wh_neg]-start
                start(gr)[wh_neg] <- start(guideSet)[wh_neg]-end
            }

            gr <- GenomicRanges::trim(gr) #Taking care of invalid values



            good <- which(as.character(strand(gr)) %in% c("+", "-"))
            out <- rep(NA_character_, length(gr))
            names(out) <- names(gr)
            if (length(good)==0){
                return(out)
            }
            if (targetOrigin(guideSet)=="customSequences"){
                seqs <- getSeq(customSequences(guideSet),gr[good])
            } else {
                seqs <- getSeq(bsgenome(guideSet), gr[good])
            }
            seqs <- as.character(seqs)

            #Making sure the sequences are not out of bound:
            len <- end-start+1 # Expected length
            seqs[seqs==""] <- NA
            seqs[nchar(seqs)<len] <- NA
            out[good] <- seqs
            return(out)
        }

        pamLength <- nchar("${params.pam}")
        crisprNuclease <- CrisprNuclease("${params.casName}",
                                 targetType="DNA",
                                 pams=c(paste0("(",pamLength,"/",pamLength,")","${params.pam}")),
                                 weights=c(1),
                                 metadata=list(description="Nuclease"),
                                 pam_side="${params.Pam_side}",
                                 spacer_length=as.numeric("${params.length}"))


        df1 <- read.table("${bedfile}", sep = "\t")

        Gr <-GRanges(seqnames = Rle(c(df1\$V1)),
                ranges = IRanges(start = c(df1\$V2),
                                     end = c(df1\$V3)), strand='+', names=c(df1\$V4))

        #Finding Spacers
        guideSet <- findSpacers(Gr,
                                bsgenome=bsgenome,
                                crisprNuclease=crisprNuclease)


        #More info
        guideSet <- addSequenceFeatures(guideSet)

        print(paste0("total number of guides " , as.character(length(spacers(guideSet, as.character=TRUE)))))

        load(paste0("${CFD_files}", '/sysdata.rda'))
        source(paste0("${CFD_files}", "/CFD_alt.R"))
        MM_score <- cfd.mm.weights.cas9
        PAM_MM <- PAM_to_DICT("${params.pam}")


        #Alignement
        chunks <- split(guideSet,ceiling(seq_along(guideSet) / chunksize))
        for (i in seq_along(chunks)) {
                                print(paste0('::message:: Processing Chunk # ', as.character(i)))
                                guideSet_iter <- chunks[[i]]
                                guideSet_iter <- addSpacerAlignmentsIterative(guideSet_iter,
                                        aligner_index=prefix_index,
                                        bsgenome=bsgenome,
                                        n_mismatches=3,
                                        alignmentThresholds=c(n0=10,
                                                 n1=100,
                                                 n2=1000,
                                                 n3=1000))
                                aln_df=mcols(alignments(guideSet_iter))
                                if ( "${params.CFD_access}" == "true"){
                                        if ("${params.casName}" == "SpCas9") {
                                             print(paste0('::message:: SPcas9 detected'))
                                             scores_cfd <- crisprScore::getCFDScores(spacers=as.character(aln_df\$spacer),
                                                                                       protospacers=as.character(aln_df\$protospacer),
                                                                                       pams=as.character(aln_df\$pam))
                                              scores_cfd <- scores_cfd[, 3] 
                                        } else {
                                          scores_cfd <- getCFDScores_ALT_cas9(
                                          as.character(aln_df\$spacer),
                                          as.character(aln_df\$protospacer),
                                          as.character(aln_df\$pam),
                                          PAM_MM,
                                          MM_score
                                        )
                                        }
                                        #Convert to dataframe easier to work with
                                        guideDF = GuideSet2DataFrames(guideSet_iter)
                                        guideDF = guideDF\$primary
                                        #Define the self aligned
                                        #Withdraw selfaligned
                                        print(scores_cfd)
                                        aln_df['CFD_score'] = as.numeric(unlist(scores_cfd))
                                        #Filter Threshold
                                        if ( "${No_CFD}" == 'F' ) {
                                            guideDF\$threshold <- CFD_T 
                                            count <- process_dna_alignments(as.data.frame(guideDF), as.data.frame(aln_df), "threshold","spacer",'CFD_score') 
                                            total <-count\$spacer
                                            pass_protospacer = count[count\$n_alignments_above_threshold<= (CFD_C+1),'spacer']
                                            fail_protospacer = count[count\$n_alignments_above_threshold> (CFD_C+1), 'spacer']
                                            spacers = spacers(guideSet) %in% pass_protospacer
                                            filtered_guideSet <- guideSet_iter[spacers(guideSet) %in% pass_protospacer]
                                            guideSet_erroring <- GuideSet2DataFrames(guideSet_iter[!(spacers(guideSet_iter) %in% total), ])
                                            failSet <- GuideSet2DataFrames(guideSet_iter[spacers(guideSet) %in% fail_protospacer, ]) #### There is a possibility of no alignement due to the PAMs and the heuristic elements ###
                                            write.table(guideSet_erroring\$primary, row.names = FALSE, quote=FALSE, sep='\t', file=paste0(SimpleName,"_problematic.txt"),  col.names= !file.exists(paste0(SimpleName,"_problematic.txt")), append   = !(i==1))
                                            print(pass_protospacer)
                                            write.table(failSet\$primary, row.names = FALSE, quote=FALSE, sep='\t', file=paste0(SimpleName,"_failed.txt"),  col.names= !file.exists(paste0(SimpleName,"_failed.txt")), append   = !(i==1))
                                                #CDF_Calc for sgRNA

                                        } else {
                                        filtered_guideSet=guideSet_iter
                                        }
                                        aln_df <- as.data.frame(aln_df)
                                        aln_df['CFD_score'] <- aln_df['CFD_score']*100
                                        df_G = GuideSet2DataFrames(filtered_guideSet)
                                        Guides_df = df_G\$primary
                                } else {
                                filtered_guideSet=guideSet_iter
                                }



                                # Output
                                extSeqs = getExtendedSequences(filtered_guideSet,-24,5)
                                Guides_df['ContextSequence'] = getExtendedSequences(filtered_guideSet,-31,7)
                                colnames(Guides_df)[4] = "Chromosome"
                                colnames(Guides_df)[8] = "PAM"
                                Guides_df['ExtendedSqueuence']=extSeqs
                                Guides_df <- subset(Guides_df, select = -region)
                                write.table(Guides_df, row.names = FALSE, quote=FALSE,   col.names= !file.exists(paste0("${bedfile.getSimpleName()}",".txt")),
                                                  append   = !(i==1), sep='\t', file=paste0("${bedfile.getSimpleName()}",".txt"))

                                write.table(aln_df, row.names = FALSE, quote=FALSE, sep='\t', file=paste0("${bedfile.getSimpleName()}","_aln.txt"),col.names= !file.exists(paste0("${bedfile.getSimpleName()}","_aln.txt")), append   = !(i==1))
        }


    """
}
