// ############################################################ ensembl based #############################################################

process install_assembly_ensembl {
  input :
   val assembly

  output :
   path("*db"), emit: db
   tuple env("assembly_full"), env("assembly_default"), env("url_name"), path("*.fa"), path("*.fai"), path("*.gff3.gz"), emit : Output_non_vep
   path("*_assembly.json") , emit: assembly_json
   path("VEP.tar.gz") , emit: assembly_VEP_cache, optional : true
   tuple env("assembly_full"), path("Annotation_folder") , emit: vep_to_untar, optional : true
   path("*.yaml"), optional : true
   path("*-blacklist.v2.bed"), optional: true
   env("location_json"), emit: location_json

publishDir "${params.install_dir}/Annotation/gffdb/${assembly}/", pattern: "*.db", mode: "move"
publishDir "${params.install_dir}/Fasta/${assembly}/", pattern: "*.fa", mode: "copy"
publishDir "${params.install_dir}/Fasta/${assembly}/", pattern: "*.fai", mode: "copy"
publishDir "${params.install_dir}/Annotation/gff/${assembly}/", pattern: "*.gff3.gz", mode: "copy"
publishDir "${params.install_dir}/Annotation/VEP_cache/${assembly}/", pattern: "VEP.tar.gz", mode: "copy"
publishDir "${params.install_dir}/Genome_dataset_apps/${assembly}/", pattern: "*_assembly.json", mode: "move"
publishDir "${params.install_dir}/Genome_dataset_apps/${assembly}/", pattern: "*.yaml", mode: "move"
publishDir "${params.install_dir}/Annotation/blacklist_region/${assembly}/", pattern: "*-blacklist.v2.bed", mode: 'move'


   script:


     """
set -euo pipefail

divisions=(
  "EnsemblVertebrates"
  "EnsemblMetazoa"
  "EnsemblPlants"
  "EnsemblFungi"
  "EnsemblProtists"
  "EnsemblBacteria"
)

for division in "\${divisions[@]}"; do
  json=\$(curl -s "http://rest.ensembl.org/info/genomes/division/\${division}?content-type=application/json")
  species_json=\$(echo "\$json" | jq -c --arg assembly "$assembly" '.[] | select(.assembly_name == "$assembly")')

  if [[ -n "\$species_json" ]]; then
    break
  fi
done

if [[ -z "\$species_json" ]]; then
  echo "::error:: ${assembly} was not found"
  exit 1
fi

name=\$(echo "\$species_json"   | jq -r '.name')
division=\$(echo "\$species_json" | jq -r '.division')
url_name=\$(echo "\$species_json" | jq -r '.url_name')
display_name=\$(echo "\$species_json" | jq -r '.display_name')
assembly_default=\$(echo "\$species_json" | jq -r '.assembly_default')
assembly_full="${assembly}"
if [[ "\$assembly_default" == "" ]] ; then
        assembly_default="${assembly}"
fi

export url_name=\$(echo "\$species_json" | jq -r '.url_name')
export assembly_default="\$assembly_default"
export assembly_full="\$assembly_full"
export location_json="${params.install_dir}/Genome_dataset_apps/${assembly}/cloudgene.yaml"
  ## ----------------------------- URL

echo \$division
case \$division in
  EnsemblVertebrates)
    release=\$(curl -s https://ftp.ensembl.org/pub/VERSION)
    vep_filename="\${url_name,,}_vep_\${release}_\${assembly_default}.tar.gz"
    vep_cache_index_url="https://ftp.ensembl.org/pub/release-\${release}/variation/indexed_vep_cache/\${vep_filename}"
    fasta_base_url="https://ftp.ensembl.org/pub/release-\${release}/fasta/\${url_name,,}/dna/"
    if wget --spider "\$fasta_base_url/\${url_name}.\${assembly_default}.dna.primary_assembly.fa.gz" 2>/dev/null; then
         fasta_filename="\${url_name}.\${assembly_default}.dna.primary_assembly.fa.gz"
    else
         fasta_filename="\${url_name}.\${assembly_default}.dna.toplevel.fa.gz"
    fi
    gff3_filename="\${url_name}.\${assembly_default}.\${release}.gff3.gz"
    gff3_url="https://ftp.ensembl.org/pub/release-\${release}/gff3/\${url_name,,}/\${gff3_filename}"
    fasta_url="\$fasta_base_url/\$fasta_filename"
    collectionnum='NA'
    ;;

  EnsemblMetazoa)
    base_URL="https://ftp.ebi.ac.uk/ensemblgenomes/pub/metazoa/"
    release=\$( lftp -c "open \$base_URL; cls -1" | grep -E '^release-[0-9]+' | sort -V | tail -n1 | grep -oE '[0-9]+' )
    base_URL="\${base_URL}/release-\${release}"
    vep_filename="\${url_name,,}_vep_\${release}_\${assembly_default}.tar.gz"
    vep_cache_index_url="\$base_URL/variation/indexed_vep_cache/\$vep_filename"
    gff3_filename="\${url_name}.\${assembly_default}.\${release}.gff3.gz"
    gff3_url="\$base_URL/gff3/\${url_name,,}/\${gff3_filename}"
    fasta_base_url="\${base_URL}/fasta/\${url_name,,}/dna/"
    if wget --spider "\$fasta_base_url/\${url_name}.\${assembly_default}.dna.primary_assembly.fa.gz" 2>/dev/null; then
         fasta_filename="\${url_name}.\${assembly_default}.dna.primary_assembly.fa.gz"
    else
         fasta_filename="\${url_name}.\${assembly_default}.dna.toplevel.fa.gz"
    fi
    fasta_url="\$fasta_base_url/\$fasta_filename"
    collectionnum='NA'
    ;;

  EnsemblPlants)
    base_URL="https://ftp.ebi.ac.uk/ensemblgenomes/pub/plants/"
    release=\$( lftp -c "open \$base_URL; cls -1" | grep -E '^release-[0-9]+' | sort -V | tail -n1 | grep -oE '[0-9]+' )
    base_URL="\${base_URL}release-\${release}"
    vep_filename="\${url_name,,}_vep_\${release}_\${assembly_default}.tar.gz"
    vep_cache_index_url="\$base_URL/variation/indexed_vep_cache/\$vep_filename"
    gff3_filename="\${url_name}.\${assembly_default}.\${release}.gff3.gz"
    gff3_url="\$base_URL/gff3/\${url_name,,}/\${gff3_filename}"
    fasta_base_url="\${base_URL}/fasta/\${url_name,,}/dna/"
    if wget --spider "\$fasta_base_url/\${url_name}.\${assembly_default}.dna.primary_assembly.fa.gz" 2>/dev/null; then
         fasta_filename="\${url_name}.\${assembly_default}.dna.primary_assembly.fa.gz"
    else
         fasta_filename="\${url_name}.\${assembly_default}.dna.toplevel.fa.gz"
    fi
    fasta_url="\$fasta_base_url/\$fasta_filename"
    collectionnum='NA'

    ;;

  EnsemblFungi)
    base_URL="https://ftp.ebi.ac.uk/ensemblgenomes/pub/fungi/"
    release=\$( lftp -c "open \$base_URL; cls -1" | grep -E '^release-[0-9]+' | sort -V | tail -n1 | grep -oE '[0-9]+' )
    base_URL="\${base_URL}/release-\${release}"
    vep_filename="\${url_name,,}_vep_\${release}_\${assembly_default}.tar.gz"
    vep_cache_index_url="\$base_URL/variation/indexed_vep_cache/\$vep_filename"
    gff3_filename="\${url_name}.\${assembly_default}.\${release}.gff3.gz"
    gff3_url="\$base_URL/gff3/\${url_name,,}/\${gff3_filename}"
    fasta_base_url="\${base_URL}/fasta/\${url_name,,}/dna/"
    if wget --spider "\$fasta_base_url/\${url_name}.\${assembly_default}.dna.primary_assembly.fa.gz" 2>/dev/null; then
         fasta_filename="\${url_name}.\${assembly_default}.dna.primary_assembly.fa.gz"
    else
         fasta_filename="\${url_name}.\${assembly_default}.dna.toplevel.fa.gz"
    fi

    fasta_url="\$fasta_base_url/\$fasta_filename"
    collectionnum='NA'
    ;;

  EnsemblProtists)
    base_URL="https://ftp.ebi.ac.uk/ensemblgenomes/pub/protists/"
    release=\$( lftp -c "open \$base_URL; cls -1" | grep -E '^release-[0-9]+' | sort -V | tail -n1 | grep -oE '[0-9]+' )
    base_URL="\${base_URL}/release-\${release}"
    vep_filename="\${url_name,,}_vep_\${release}_\${assembly_default}.tar.gz"
    vep_cache_index_url="\$base_URL/variation/indexed_vep_cache/\$vep_filename"
    gff3_filename="\${url_name}.\${assembly_default}.\${release}.gff3.gz"
    gff3_url="\$base_URL/gff3/\${url_name,,}/\${gff3_filename}"
    fasta_base_url="\${base_URL}/fasta/\${url_name,,}/dna/"
    if wget --spider "\$fasta_base_url/\${url_name}.\${assembly_default}.dna.primary_assembly.fa.gz" 2>/dev/null; then
         fasta_filename="\${url_name}.\${assembly_default}.dna.primary_assembly.fa.gz"
    else
         fasta_filename="\${url_name}.\${assembly_default}.dna.toplevel.fa.gz"
    fi

    fasta_url="\$fasta_base_url/\$fasta_filename"
    collectionnum='NA'

    ;;

  EnsemblBacteria)
    base_URL="https://ftp.ensemblgenomes.ebi.ac.uk/pub/bacteria/"
    release=\$( lftp -c "open \$base_URL; cls -1" | grep -E '^release-[0-9]+' | sort -V | tail -n1 | grep -oE '[0-9]+' )
    wget "https://ftp.ensemblgenomes.org/pub/bacteria/release-\$release/species_EnsemblBacteria.txt"
    coredb_field=\$(head -n 1 species_EnsemblBacteria.txt | tr '\t' '\n' | grep -nFx "core_db" | cut -d: -f1)
    assembly_field=\$(head -n 1 species_EnsemblBacteria.txt | tr '\t' '\n' | grep -nFx "assembly" | cut -d: -f1)
    collectionnum=\$(awk -F'\t' -v field="\$assembly_field" '\$field ~ /${assembly}/' species_EnsemblBacteria.txt | cut -f \$coredb_field | awk -F'[_]' '{print \$2}')
    echo "\$collectionnum"
    collection="bacteria_"\$collectionnum"_collection"
    fasta_base_url="\${base_URL}/release-\${release}/fasta/\${collection}/\${url_name,,}/dna/"
    if wget --spider "\$fasta_base_url/\${url_name}.\${assembly_default}.dna.primary_assembly.fa.gz" 2>/dev/null; then
         fasta_filename="\${url_name}.\${assembly_default}.dna.primary_assembly.fa.gz"
    else
         fasta_filename="\${url_name}.\${assembly_default}.dna.toplevel.fa.gz"
    fi
    fasta_url="\$fasta_base_url/\$fasta_filename"
    gff3_url="\${base_URL}/release-\${release}/gff3/\${collection}/\${url_name,,}/\${url_name}.\${assembly_default}.\${release}.gff3.gz"
    gff3_filename="\${url_name}.\${assembly_default}.\${release}.gff3.gz"
    vep_cache_index_url="\${base_URL}/release-\${release}/variation/indexed_vep_cache/\${collection}/\${url_name,,}_vep_\${release}_\${assembly_default}.tar.gz"
    echo "\$vep_cache_index_url"
    vep_filename="\${url_name,,}_vep_\${release}_\${assembly_default}.tar.gz"
    ;;

esac

if [[ "\$species_json" ]]; then
echo "::group type=message::"
echo "${assembly} was found"
echo "- Divions :              \$division"
echo "- Release :              \$release"
echo "- Display name :         \$display_name"
echo "- Vep cache :            \$vep_cache_index_url"
echo "- Genomic Annotation :   \$gff3_url"
echo "- Fasta file :           \$fasta_url"
echo "- Collection :            \$collectionnum"
echo "::endgroup::"
fi
echo \$species_json > ${assembly}.assembly
## ----------------------------- VEP_cache


echo "::message:: Downloading VEP Cache"
wget \$vep_cache_index_url

threshold=\$((${params.vep_threshold} * 1024**3))

# File is decompressed if too large,
# will be used as a linked
# folder afterwards (only really applies to human genomes)


size=\$(stat -c%s \${vep_filename})

if (( size > \$threshold )); then
  echo "::message:: ⚠️  \$vep_filename is larger than ${params.vep_threshold} GiB (\$size bytes)"
  folder=\${url_name,,}
  mkdir Annotation_folder/
  mv \$vep_filename Annotation_folder/
  vep_filename="Annotation_VEP/"
 else
  mv \$vep_filename VEP.tar.gz
  vep_filename='VEP.tar.gz'
  echo "::message:: ✅  \$vep_filename is under ${params.vep_threshold} GiB (\$size bytes)"
fi

## ---------------------------- fasta

echo "::message:: Processing fasta"

wget \$fasta_url
gunzip -f \$fasta_filename
awk '{print \$1}' \${fasta_filename%.gz} > \${assembly_default}.fa
rm \${fasta_filename%.gz}
fasta=\${assembly_default}.fa


## ----------------------------- GFF

echo "::message:: Processing Annotation File"
wget \${gff3_url}

create_gffutilDB.py -G \${gff3_filename} -O \${assembly_default}

## ---------------------------- Rbsgenome

samtools faidx "\${assembly_default}.fa"

## ---------------------------- Encode Blacklikst

#boyle_url="https://cerc-genomic-medicine.ca/Data/Boyle_lab_blackList/\${assembly_default}-blacklist.v2.bed"

#if ! curl -fsSL "\${boyle_url}"; then
    boyle_loc=""
    boyle_url=""
#else
#    boyle_loc="${params.install_dir}/Annotation/blacklist_region/${assembly}/\${assembly_default}-blacklist.v2.bed"
#fi
#

## ----------------------------- Produce Json

echo "::message:: Creating json file"


fasta_dir="${params.install_dir}/Fasta/${assembly}"
gffdb_dir="${params.install_dir}/Annotation/gffdb/${assembly}"
vep_cache_dir="${params.install_dir}/Annotation/VEP_cache/${assembly}"
bowtie_index_loc="${params.install_dir}/Bowtie_index/${assembly}/${assembly}.1.ebwt"
bsgenome_dir="${params.install_dir}/Annotation/Rpackage/${assembly}/"

gffdb_loc="\${gffdb_dir}/\${assembly_default}.db"
gff3_loc="${params.install_dir}/Annotation/gff/${assembly}/\${url_name}.\${assembly_default}.\${release}.gff3.gz"

vep_cache_loc="\${vep_cache_dir}/\$vep_filename"
fasta_loc="\${fasta_dir}/\${assembly_default}.fa"
bsgenome_loc="\$bsgenome_dir/BSgenome.tar.gz"



echo \$assembly_full
echo \$assembly_default
echo \$url_name
echo \$location_json

jq -n \
  --argjson spjson1 "\$species_json" \
  --arg source1 "ensembl" \
  --arg release1 \$release \
  --arg vep_cache_index_url1 "\$vep_cache_index_url" \
  --arg fasta_url1 "\$fasta_url" \
  --arg gff3_url1 "\$gff3_url" \
  --arg fasta_loc1 "\$fasta_loc" \
  --arg gffdb_loc1 "\$gffdb_loc" \
  --arg bsgenome_loc1 "\$bsgenome_loc" \
  --arg vep_cache_loc1 "\$vep_cache_loc" \
  --arg gff3_loc1 "\$gff3_loc" \
  --arg boyle_loc1 "\$boyle_loc"\
  --arg boyle_url1 "\$boyle_url"\
  --arg bowtie_index_loc1 "\$bowtie_index_loc" \
  --arg blacklist_region_loc1 "${params.install_dir}/Annotation/blacklist_region/${assembly}/" \
  --slurpfile mane_data1 "\${assembly_default}_gff.json" \
  '{ "${assembly}" :
    { release : \$release1,
    source : \$source1,
    species_info: \$spjson1,
    mane_select:    \$mane_data1[0].mane_select,
    urls: {
      vep_cache: \$vep_cache_index_url1,
      fasta:    \$fasta_url1,
      gff3:     \$gff3_url1,
      blacklist_regions_url : {
        Boyle_Lab_url :   \$boyle_url1,
        Dust_repeat_url : "",
        repeatmasquer_url : ""
      },
    },
    paths: {
      fasta_loc:      \$fasta_loc1,
      gffdb_loc:      \$gffdb_loc1,
      gff3_loc:         \$gff3_loc1,
      vep_cache_loc:  \$vep_cache_loc1,
      bowtie_index_loc:   \$bowtie_index_loc1,
      bsgenome_loc:           \$bsgenome_loc1,
      blacklist_regions : {
        Boyle_Lab :   \$boyle_loc1,
        Dust_repeat: "",
        repeatmasquer  : ""
      }
    },
    first_genes:    \$mane_data1[0].first_genes
}}' > \${assembly_default}_assembly.json

echo "id: \${assembly_default}" > "cloudgene.yaml"
echo "name: \${name} - \${assembly_default}" >> "cloudgene.yaml"
echo "version: \${release}" >> "cloudgene.yaml"
echo "category: genomic_database" >> "cloudgene.yaml"
echo "properties:" >> "cloudgene.yaml"
echo "  database_url: \"\\\${CLOUDGENE_APP_LOCATION}/\${assembly_default}_assembly.json\"" >> "cloudgene.yaml"
"""
}

// ############################################################ Bowtie #############################################################

process bowtie {
  input :
  tuple val(assembly), val(assembly_default), val(url_name), path(fasta), path(index), path(gff)
  output :
  path("*.ebwt") , emit: assembly_bowtie
  val("OK"), emit: OK


  publishDir "${params.install_dir}/Bowtie_index/${assembly}/", pattern: "*.ebwt", mode: "move"


   script:

     """

set -euo pipefail

echo "bowtie ${fasta.baseName}"


 bowtie-build ${fasta} ${fasta.baseName}
"""
}

process RBSname {
  input :
  tuple val(assembly), val(default_assembly), val(URLname), path(fasta), path(index), path(gff)

  output :
   path("BSgenome.tar.gz") , emit: assembly_bsgenome
   val("OK"), emit: OK


publishDir "${params.install_dir}/Annotation/Rpackage/${assembly}/", pattern: "BSgenome.tar.gz", mode: "move"

   script:
     """

echo "r BSgenome ${assembly}"
faToTwoBit ${fasta} ${fasta.baseName}.2bit


create_bsforge.R ${URLname} ${default_assembly} ${fasta.baseName}.2bit ${gff} ensembl

tarball=\$(ls | grep BSgenome*)
tar -czvf BSgenome.tar.gz \$tarball

"""
}


process unTARvep {
  input :
  tuple val(assembly), path(VEP)

  output :
   path("Annotation_VEP") , emit: assembly_bsgenome
   val("OK"), emit: OK


publishDir "${params.install_dir}/Annotation/VEP_cache/${assembly}/", pattern: "Annotation_VEP", mode: "move"

   script:
     """
mv Annotation_folder Annotation_VEP
cd Annotation_VEP
tarball=\$(ls *.tar.gz)
tar -xzf "\$tarball"
"""
}

